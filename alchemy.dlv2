%the player starts with 4 life points.
%the player loses if they lose all the life points.

%a rune can be one of four types: a b c d.
%a rune can be one of four colors: red green blue magenta.

%a cell can be in one combination of two types: free or busy, incomplete or completed.
%all the cells of a row or column become completed
%if all the cells are busy, and all the cells become free.

%the objective of the game is to complete all the cells.
%the player gets a rune for every turn.
%the rune may be placed or sacrificed.
%a rune can be placed only next to a rune of the same type and/or color.
%every rune placed in an incomplete cell is +5 points, +1 life point.
%every rune placed in a complete cell is +1 point.
%every rune sacrificed is -2 points, -1 life point.

%there is a special type of rune, the blank:
%it may be placed next to any rune, and can not be sacrificed.
%by default, the central spot is occupied by the central rune.

%busyCell(X,Y,T,Col,Comp).
%emptyCell(X,Y,Comp).
%inputRune(T,C).
%sizeOfMatrix(S).

%computing all the numbers in the matrix
n(0).
n(X) :- n(X-1), X < S, sizeOfMatrix(S).

%computing all the neighbor cells
neighbors(X,Y,X,Y1) :- Y1 = Y + 1, n(X), n(Y), n(Y1).
neighbors(X,Y,X1,Y) :- X1 = X + 1, n(X), n(X1), n(Y).
neighbors(X,Y,X1,Y1) :- neighbors(X1,Y1,X,Y).

%A rune can be placed only in an empty cell adjacent to a busycell
solution(X,Y) | notSolution(X,Y) :- emptyCell(X,Y,_), neighbors(X,Y,X1,Y1), busyCell(X1,Y1,_,_,_), inputRune(T,C).

%a rune can be placed only adjacent to a rune with the same type or color
:- solution(X,Y), inputRune(T,C), neighbors(X,Y,X1,Y1), busyCell(X1,Y1,T1,C1,_), T != T1, C != C1, T!= 0, T1 != 0.

%is the matrix all empty cells?
isEmpty(1) :- #count{X1, Y1: emptyCell(X1,Y1,_)} = M, M = S*S, sizeOfMatrix(S).

%guess for the limit case in which the matrix is all empty cells
solution(X,Y) | notSolution(X,Y) :- emptyCell(X,Y,0), isEmpty(1).

%if the board is empty, try to put the cell as centred as possible
:~ isEmpty(1), solution(X,Y), sizeOfMatrix(S), S/2 = M, #absdiff{X,M,PX}, #absdiff{Y,M,PY}. [PX+PY@4]

%there should be 0 or 1 solutions, 1 is preferred
:- #count{X,Y : solution(X,Y)} > 1.
:~ #count{X,Y : solution(X,Y)} = 0. [1@10]

%it is preferred to place the inputRune in a crowded situation
:~ solution(X,Y), #count{X2,Y2: neighbors(X,Y,X2,Y2), busyCell(X2,Y2,_,_,_)} = B. [4-B@2]

%an incomplete cell is preferred, but not necessary
:~ solution(X,Y), emptyCell(X,Y,1). [1@3]

%prefer not to place next to a blank rune
:~ solution(X,Y), neighbors(X,Y,X1,Y1), busyCell(X1,Y1,0,_,_). [1@5]
:~ solution(X,Y), neighbors(X,Y,X1,Y1), busyCell(X1,Y1,0,_,_), inputRune(0,_). [10@5]

crowded(X,Y,Comp,TX,CX) :- #count{T: neighbors(X,Y,X1,Y1), busyCell(X1,Y1,T,_,_), T != 0} = TX, #count{C: neighbors(X,Y,X2,Y2), busyCell(X2,Y2,_,C,_), C != 0} = CX, emptyCell(X,Y,Comp).

:~ solution(X,Y), crowded(X,Y,Comp,TX,CX), inputRune(0,_), not isEmpty(1). [9-TX-CX-Comp@4]
